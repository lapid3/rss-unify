// module exports
exports.aggregate = aggregate;

// module vars
var feedparser = require('feedparser')
	RSS = require('rss'),
	async = require('async'),
	// array of all articles from all feeds
	items = new Array();


/**
 * Agreggate the feeds
 * @param topic - the topic to aggregate
 * @param callback - the callback dealing with the answered rss feed
 * @param req - the sent request
 */
function aggregate(topic, callback, req) {	
	// clear array
	items.length = 0;
	// async fetch of each feed
	async.forEach(topic.feeds, 
		function(item, callback) {
			parseAndProcessFeed(item, callback);
		}, 
		function(err) {
			// sort items by date
			items.sort(function(a, b) {
			    return (Date.parse(b.date) - Date.parse(a.date));
			});
			// create the feed
			var rssFeed = createAggregatedFeed(topic, req);
			callback(err, rssFeed);
		}
	);
}

/**
 * Parse and process a feed
 * @param feedUrl - the url to parse
 * @param callback - the callback which is called to indicate async lib that the parsing of this feed is done
 */
function parseAndProcessFeed(feedUrl, callback) {
	var now = new Date();
	var item;
	// when parsing is finished, iterate over articles to store them in an array of all articles of all streams
	feedparser.parseUrl(feedUrl).on('complete', function onComplete(meta, articles) {
		for (var article in articles) {
			// some people put a future date as the pubDate of their articles to stay on top of aggregated feeds, fuck them
			if (now > Date.parse(articles[article].date)) {
				item = new RssItem(articles[article].title, articles[article].summary, articles[article].link, articles[article].author, articles[article].date);
				items.push(item);
			}
		}
		// tell async that this parse and process is finished
		callback();
	});
}

/**
 * Create the aggregated feed
 * @param topic - the topic document of the searched feed
 * @param req - the request that triggered the creation of the feed
 * @returns the xml representation of the aggregated feed
 */
function createAggregatedFeed(topic, req) {
	// create the feed
	var feed = new RSS({
		title: 'Aggegated feed about ' + topic.name,
        description: topic.description,
        feed_url: req.protocol + '://' + req.host + req.url,
        site_url: req.protocol + '://' + req.host,
        author: 'Generated by rss-unify'
	});
	// number of requested feed items
	var numberOfItems = 10;
	if (req.params.size) {
		var size = req.params.size;
		if(size <= items.length) {
			numberOfItems = size;
		}
		else {
			numberOfItems = items.length;
		}
	}
	// get the 'numberOfItems' first rss items to create the feed
	for (var i=0; i<numberOfItems; i++) {
		feed.item({
			title:  items[i].title,
			description: items[i].desc,
			url: items[i].url, 
			author: items[i].author, 
			date: items[i].date
		});
	}
	// return the xml feed
	return feed.xml();
}

/**
 * Object representation of an article
 * @param title - its title
 * @param desc - its description
 * @param url - its url
 * @param author - its author
 * @param date - its date
 * @returns a RSSItem
 */
function RssItem(title, desc, url, author, date) { 
    if (title) {this.title = title;} else {this.title = 'missing'}
	if (desc) {this.desc = desc;} else {this.desc = 'missing'}
    if (url) {this.url = url;} else {this.url = 'missing'}
    if (author) {this.author = author;} else {this.author = 'missing'}
    if (date) {this.date = date;} else {this.date = 'missing'}
} 